#!/usr/bin/env node

/**
 * AI Chat Plugin MCP Browser Server
 * ÂÖÅËÆ∏ AI ËÆøÈóÆÂíåÂàÜÊûêÁΩëÈ°µÂÜÖÂÆπ
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
import puppeteer from 'puppeteer';
import axios from 'axios';
import * as cheerio from 'cheerio';

class BrowserServer {
  constructor() {
    this.server = new Server(
      {
        name: 'ai-chat-plugin-browser',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.browser = null;
    this.setupToolHandlers();
    
    // ÈîôËØØÂ§ÑÁêÜ
    this.server.onerror = (error) => console.error('[MCP Error]', error);
    process.on('SIGINT', () => this.cleanup());
  }

  setupToolHandlers() {
    // ÂàóÂá∫ÂèØÁî®Â∑•ÂÖ∑
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: [
        {
          name: 'visit_webpage',
          description: 'ËÆøÈóÆÊåáÂÆöÁΩëÈ°µÂπ∂Ëé∑ÂèñÂÜÖÂÆπ',
          inputSchema: {
            type: 'object',
            properties: {
              url: {
                type: 'string',
                description: 'Ë¶ÅËÆøÈóÆÁöÑÁΩëÈ°µURL',
              },
              wait_for_selector: {
                type: 'string',
                description: 'Á≠âÂæÖÁâπÂÆöÂÖÉÁ¥†Âä†ËΩΩÔºàÂèØÈÄâÔºâ',
              },
              screenshot: {
                type: 'boolean',
                description: 'ÊòØÂê¶Êà™ÂõæÔºàÂèØÈÄâÔºâ',
                default: false,
              },
            },
            required: ['url'],
          },
        },
        {
          name: 'analyze_page_content',
          description: 'ÂàÜÊûêÁΩëÈ°µÂÜÖÂÆπÁªìÊûÑ',
          inputSchema: {
            type: 'object',
            properties: {
              url: {
                type: 'string',
                description: 'Ë¶ÅÂàÜÊûêÁöÑÁΩëÈ°µURL',
              },
              focus_area: {
                type: 'string',
                description: 'ÈáçÁÇπÂàÜÊûêÁöÑÂå∫ÂüüÔºàÂ¶ÇÔºöË°®Âçï„ÄÅÂØºËà™„ÄÅÂÜÖÂÆπÂå∫ÂüüÁ≠âÔºâ',
              },
            },
            required: ['url'],
          },
        },
        {
          name: 'check_api_endpoints',
          description: 'Ê£ÄÊü•ÁΩëÈ°µ‰∏≠ÁöÑAPIÁ´ØÁÇπÂíåÁΩëÁªúËØ∑Ê±Ç',
          inputSchema: {
            type: 'object',
            properties: {
              url: {
                type: 'string',
                description: 'Ë¶ÅÊ£ÄÊü•ÁöÑÁΩëÈ°µURL',
              },
              duration: {
                type: 'number',
                description: 'ÁõëÊéßÊó∂ÈïøÔºàÁßíÔºâ',
                default: 10,
              },
            },
            required: ['url'],
          },
        },
        {
          name: 'test_form_interaction',
          description: 'ÊµãËØïÁΩëÈ°µË°®Âçï‰∫§‰∫í',
          inputSchema: {
            type: 'object',
            properties: {
              url: {
                type: 'string',
                description: 'ÂåÖÂê´Ë°®ÂçïÁöÑÁΩëÈ°µURL',
              },
              form_selector: {
                type: 'string',
                description: 'Ë°®ÂçïÈÄâÊã©Âô®',
                default: 'form',
              },
              test_data: {
                type: 'object',
                description: 'ÊµãËØïÊï∞ÊçÆÈîÆÂÄºÂØπ',
              },
            },
            required: ['url'],
          },
        },
        {
          name: 'extract_errors',
          description: 'ÊèêÂèñÁΩëÈ°µ‰∏≠ÁöÑÈîôËØØ‰ø°ÊÅØ',
          inputSchema: {
            type: 'object',
            properties: {
              url: {
                type: 'string',
                description: 'Ë¶ÅÊ£ÄÊü•ÁöÑÁΩëÈ°µURL',
              },
            },
            required: ['url'],
          },
        },
      ],
    }));

    // Â§ÑÁêÜÂ∑•ÂÖ∑Ë∞ÉÁî®
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        switch (name) {
          case 'visit_webpage':
            return await this.visitWebpage(args);
          case 'analyze_page_content':
            return await this.analyzePageContent(args);
          case 'check_api_endpoints':
            return await this.checkApiEndpoints(args);
          case 'test_form_interaction':
            return await this.testFormInteraction(args);
          case 'extract_errors':
            return await this.extractErrors(args);
          default:
            throw new Error(`Unknown tool: ${name}`);
        }
      } catch (error) {
        return {
          content: [
            {
              type: 'text',
              text: `Error: ${error.message}`,
            },
          ],
        };
      }
    });
  }

  async ensureBrowser() {
    if (!this.browser) {
      this.browser = await puppeteer.launch({
        headless: 'new',
        args: ['--no-sandbox', '--disable-setuid-sandbox'],
      });
    }
    return this.browser;
  }

  async visitWebpage(args) {
    const { url, wait_for_selector, screenshot = false } = args;
    
    const browser = await this.ensureBrowser();
    const page = await browser.newPage();
    
    try {
      // ËÆæÁΩÆÁî®Êà∑‰ª£ÁêÜ
      await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36');
      
      // ËÆøÈóÆÈ°µÈù¢
      await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });
      
      // Á≠âÂæÖÁâπÂÆöÂÖÉÁ¥†ÔºàÂ¶ÇÊûúÊåáÂÆöÔºâ
      if (wait_for_selector) {
        await page.waitForSelector(wait_for_selector, { timeout: 10000 });
      }
      
      // Ëé∑ÂèñÈ°µÈù¢ÂÜÖÂÆπ
      const content = await page.content();
      const title = await page.title();
      const currentUrl = page.url();
      
      // ÊèêÂèñÂÖ≥ÈîÆ‰ø°ÊÅØ
      const $ = cheerio.load(content);
      const textContent = $('body').text().substring(0, 5000); // ÈôêÂà∂ÈïøÂ∫¶
      
      let result = {
        url: currentUrl,
        title,
        textContent,
        htmlLength: content.length,
        timestamp: new Date().toISOString(),
      };
      
      // Êà™ÂõæÔºàÂ¶ÇÊûúÈúÄË¶ÅÔºâ
      if (screenshot) {
        const screenshotBuffer = await page.screenshot({ fullPage: true });
        result.screenshot = screenshotBuffer.toString('base64');
      }
      
      return {
        content: [
          {
            type: 'text',
            text: `‚úÖ ÊàêÂäüËÆøÈóÆÁΩëÈ°µ: ${url}

üìä È°µÈù¢‰ø°ÊÅØ:
- Ê†áÈ¢ò: ${title}
- ÂΩìÂâçURL: ${currentUrl}
- HTMLÈïøÂ∫¶: ${content.length} Â≠óÁ¨¶
- ËÆøÈóÆÊó∂Èó¥: ${result.timestamp}

üìù È°µÈù¢ÂÜÖÂÆπÈ¢ÑËßà:
${textContent.substring(0, 1000)}${textContent.length > 1000 ? '...' : ''}

${screenshot ? 'üì∏ È°µÈù¢Êà™ÂõæÂ∑≤ÁîüÊàê' : ''}`,
          },
        ],
      };
      
    } finally {
      await page.close();
    }
  }

  async analyzePageContent(args) {
    const { url, focus_area } = args;
    
    const browser = await this.ensureBrowser();
    const page = await browser.newPage();
    
    try {
      await page.goto(url, { waitUntil: 'networkidle2' });
      
      // ÂàÜÊûêÈ°µÈù¢ÁªìÊûÑ
      const analysis = await page.evaluate((focusArea) => {
        const result = {
          forms: [],
          buttons: [],
          inputs: [],
          links: [],
          apis: [],
          errors: [],
          structure: {},
        };
        
        // ÂàÜÊûêË°®Âçï
        document.querySelectorAll('form').forEach((form, index) => {
          const formData = {
            index,
            action: form.action,
            method: form.method,
            inputs: [],
          };
          
          form.querySelectorAll('input, select, textarea').forEach(input => {
            formData.inputs.push({
              type: input.type,
              name: input.name,
              id: input.id,
              placeholder: input.placeholder,
              required: input.required,
            });
          });
          
          result.forms.push(formData);
        });
        
        // ÂàÜÊûêÊåâÈíÆ
        document.querySelectorAll('button, input[type="button"], input[type="submit"]').forEach(btn => {
          result.buttons.push({
            text: btn.textContent || btn.value,
            type: btn.type,
            id: btn.id,
            className: btn.className,
            onclick: btn.onclick ? 'Has click handler' : 'No click handler',
          });
        });
        
        // ÂàÜÊûêÈìæÊé•
        document.querySelectorAll('a[href]').forEach(link => {
          if (link.href.includes('/api/')) {
            result.apis.push({
              href: link.href,
              text: link.textContent,
            });
          } else {
            result.links.push({
              href: link.href,
              text: link.textContent.substring(0, 50),
            });
          }
        });
        
        // Ê£ÄÊü•ÈîôËØØ‰ø°ÊÅØ
        const errorSelectors = ['.error', '.alert-danger', '.notification.error', '[class*="error"]'];
        errorSelectors.forEach(selector => {
          document.querySelectorAll(selector).forEach(el => {
            if (el.textContent.trim()) {
              result.errors.push({
                selector,
                text: el.textContent.trim(),
                visible: el.offsetParent !== null,
              });
            }
          });
        });
        
        // È°µÈù¢ÁªìÊûÑÂàÜÊûê
        result.structure = {
          totalElements: document.querySelectorAll('*').length,
          scripts: document.querySelectorAll('script').length,
          stylesheets: document.querySelectorAll('link[rel="stylesheet"]').length,
          images: document.querySelectorAll('img').length,
          hasJQuery: typeof window.jQuery !== 'undefined',
          hasReact: typeof window.React !== 'undefined',
          hasVue: typeof window.Vue !== 'undefined',
        };
        
        return result;
      }, focus_area);
      
      return {
        content: [
          {
            type: 'text',
            text: `üîç È°µÈù¢ÂÜÖÂÆπÂàÜÊûêÊä•Âëä: ${url}

üìã Ë°®ÂçïÂàÜÊûê (${analysis.forms.length} ‰∏™):
${analysis.forms.map((form, i) => `
  Ë°®Âçï ${i + 1}:
  - Action: ${form.action || 'Êú™ËÆæÁΩÆ'}
  - Method: ${form.method || 'GET'}
  - ËæìÂÖ•Â≠óÊÆµ: ${form.inputs.length} ‰∏™
    ${form.inputs.map(input => `    ‚Ä¢ ${input.name || input.id}: ${input.type}`).join('\n')}
`).join('')}

üîò ÊåâÈíÆÂàÜÊûê (${analysis.buttons.length} ‰∏™):
${analysis.buttons.slice(0, 10).map(btn => `  ‚Ä¢ "${btn.text}" (${btn.type}) - ${btn.onclick}`).join('\n')}

üîó API Á´ØÁÇπ (${analysis.apis.length} ‰∏™):
${analysis.apis.map(api => `  ‚Ä¢ ${api.href}`).join('\n')}

‚ùå ÈîôËØØ‰ø°ÊÅØ (${analysis.errors.length} ‰∏™):
${analysis.errors.map(error => `  ‚Ä¢ ${error.text} (${error.visible ? 'ÂèØËßÅ' : 'ÈöêËóè'})`).join('\n')}

üèóÔ∏è È°µÈù¢ÁªìÊûÑ:
- ÊÄªÂÖÉÁ¥†Êï∞: ${analysis.structure.totalElements}
- JavaScript Êñá‰ª∂: ${analysis.structure.scripts}
- CSS Êñá‰ª∂: ${analysis.structure.stylesheets}
- ÂõæÁâá: ${analysis.structure.images}
- ÂâçÁ´ØÊ°ÜÊû∂: ${analysis.structure.hasReact ? 'React' : analysis.structure.hasVue ? 'Vue' : analysis.structure.hasJQuery ? 'jQuery' : 'ÂéüÁîüJS'}

${focus_area ? `\nüéØ ÈáçÁÇπÂàÜÊûêÂå∫Âüü: ${focus_area}` : ''}`,
          },
        ],
      };
      
    } finally {
      await page.close();
    }
  }

  async checkApiEndpoints(args) {
    const { url, duration = 10 } = args;
    
    const browser = await this.ensureBrowser();
    const page = await browser.newPage();
    
    const networkRequests = [];
    
    try {
      // ÁõëÂê¨ÁΩëÁªúËØ∑Ê±Ç
      page.on('request', request => {
        networkRequests.push({
          url: request.url(),
          method: request.method(),
          headers: request.headers(),
          postData: request.postData(),
          timestamp: Date.now(),
        });
      });
      
      page.on('response', response => {
        const request = networkRequests.find(req => req.url === response.url());
        if (request) {
          request.status = response.status();
          request.statusText = response.statusText();
          request.responseHeaders = response.headers();
        }
      });
      
      await page.goto(url, { waitUntil: 'networkidle2' });
      
      // Á≠âÂæÖÊåáÂÆöÊó∂Èó¥‰ª•ÊçïËé∑Êõ¥Â§öËØ∑Ê±Ç
      await new Promise(resolve => setTimeout(resolve, duration * 1000));
      
      // Â∞ùËØïËß¶Âèë‰∏Ä‰∫õ‰∫§‰∫í
      await page.evaluate(() => {
        // ÁÇπÂáª‰∏Ä‰∫õÊåâÈíÆ
        document.querySelectorAll('button, [data-action]').forEach((btn, i) => {
          if (i < 3) { // Âè™ÁÇπÂáªÂâç3‰∏™
            try {
              btn.click();
            } catch (e) {
              console.log('Click failed:', e);
            }
          }
        });
      });
      
      // ÂÜçÁ≠âÂæÖ‰∏ÄÊÆµÊó∂Èó¥
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // ÂàÜÊûêAPIËØ∑Ê±Ç
      const apiRequests = networkRequests.filter(req => 
        req.url.includes('/api/') || 
        req.method !== 'GET' ||
        req.url.includes('json')
      );
      
      return {
        content: [
          {
            type: 'text',
            text: `üåê ÁΩëÁªúËØ∑Ê±ÇÂàÜÊûêÊä•Âëä: ${url}

üìä ÊÄªËØ∑Ê±ÇÊï∞: ${networkRequests.length}
üîó API ËØ∑Ê±ÇÊï∞: ${apiRequests.length}

üîç API Á´ØÁÇπËØ¶ÊÉÖ:
${apiRequests.map(req => `
  ${req.method} ${req.url}
  Áä∂ÊÄÅ: ${req.status || 'ÂæÖÂìçÂ∫î'} ${req.statusText || ''}
  Êó∂Èó¥: ${new Date(req.timestamp).toLocaleTimeString()}
  ${req.postData ? `Êï∞ÊçÆ: ${req.postData.substring(0, 200)}` : ''}
`).join('\n')}

üìà ËØ∑Ê±ÇÁªüËÆ°:
- GET: ${networkRequests.filter(r => r.method === 'GET').length}
- POST: ${networkRequests.filter(r => r.method === 'POST').length}
- PUT: ${networkRequests.filter(r => r.method === 'PUT').length}
- DELETE: ${networkRequests.filter(r => r.method === 'DELETE').length}

‚ùå Â§±Ë¥•ËØ∑Ê±Ç:
${networkRequests.filter(r => r.status >= 400).map(r => `  ‚Ä¢ ${r.method} ${r.url} - ${r.status}`).join('\n')}`,
          },
        ],
      };
      
    } finally {
      await page.close();
    }
  }

  async testFormInteraction(args) {
    const { url, form_selector = 'form', test_data = {} } = args;
    
    const browser = await this.ensureBrowser();
    const page = await browser.newPage();
    
    try {
      await page.goto(url, { waitUntil: 'networkidle2' });
      
      const results = await page.evaluate((selector, data) => {
        const form = document.querySelector(selector);
        if (!form) {
          return { error: 'Êú™ÊâæÂà∞ÊåáÂÆöË°®Âçï' };
        }
        
        const results = {
          formFound: true,
          interactions: [],
          errors: [],
        };
        
        // Â°´ÂÖÖË°®ÂçïÊï∞ÊçÆ
        Object.entries(data).forEach(([key, value]) => {
          const input = form.querySelector(`[name="${key}"], #${key}`);
          if (input) {
            try {
              input.value = value;
              input.dispatchEvent(new Event('input', { bubbles: true }));
              results.interactions.push(`‚úÖ ËÆæÁΩÆ ${key} = ${value}`);
            } catch (e) {
              results.errors.push(`‚ùå Êó†Ê≥ïËÆæÁΩÆ ${key}: ${e.message}`);
            }
          } else {
            results.errors.push(`‚ùå Êú™ÊâæÂà∞Â≠óÊÆµ: ${key}`);
          }
        });
        
        return results;
      }, form_selector, test_data);
      
      return {
        content: [
          {
            type: 'text',
            text: `üß™ Ë°®Âçï‰∫§‰∫íÊµãËØïÊä•Âëä: ${url}

${results.error ? `‚ùå ${results.error}` : `‚úÖ Ë°®ÂçïÊµãËØïÂÆåÊàê

üìù ‰∫§‰∫íËÆ∞ÂΩï:
${results.interactions.join('\n')}

${results.errors.length > 0 ? `\n‚ùå ÈîôËØØËÆ∞ÂΩï:\n${results.errors.join('\n')}` : ''}`}`,
          },
        ],
      };
      
    } finally {
      await page.close();
    }
  }

  async extractErrors(args) {
    const { url } = args;
    
    const browser = await this.ensureBrowser();
    const page = await browser.newPage();
    
    const consoleErrors = [];
    const networkErrors = [];
    
    try {
      // ÁõëÂê¨ÊéßÂà∂Âè∞ÈîôËØØ
      page.on('console', msg => {
        if (msg.type() === 'error') {
          consoleErrors.push({
            text: msg.text(),
            location: msg.location(),
            timestamp: Date.now(),
          });
        }
      });
      
      // ÁõëÂê¨ÁΩëÁªúÈîôËØØ
      page.on('requestfailed', request => {
        networkErrors.push({
          url: request.url(),
          failure: request.failure().errorText,
          method: request.method(),
        });
      });
      
      await page.goto(url, { waitUntil: 'networkidle2' });
      
      // ÊèêÂèñÈ°µÈù¢‰∏≠ÁöÑÈîôËØØÂÖÉÁ¥†
      const pageErrors = await page.evaluate(() => {
        const errors = [];
        const errorSelectors = [
          '.error', '.alert-danger', '.notification.error', 
          '[class*="error"]', '.text-danger', '.has-error'
        ];
        
        errorSelectors.forEach(selector => {
          document.querySelectorAll(selector).forEach(el => {
            if (el.textContent.trim() && el.offsetParent !== null) {
              errors.push({
                selector,
                text: el.textContent.trim(),
                className: el.className,
              });
            }
          });
        });
        
        return errors;
      });
      
      return {
        content: [
          {
            type: 'text',
            text: `üö® ÈîôËØØÊèêÂèñÊä•Âëä: ${url}

üì± È°µÈù¢ÈîôËØØÂÖÉÁ¥† (${pageErrors.length} ‰∏™):
${pageErrors.map(error => `  ‚Ä¢ ${error.text} (${error.selector})`).join('\n')}

üñ•Ô∏è ÊéßÂà∂Âè∞ÈîôËØØ (${consoleErrors.length} ‰∏™):
${consoleErrors.map(error => `  ‚Ä¢ ${error.text} - ${error.location?.url}:${error.location?.lineNumber}`).join('\n')}

üåê ÁΩëÁªúÈîôËØØ (${networkErrors.length} ‰∏™):
${networkErrors.map(error => `  ‚Ä¢ ${error.method} ${error.url} - ${error.failure}`).join('\n')}

${pageErrors.length === 0 && consoleErrors.length === 0 && networkErrors.length === 0 ? '‚úÖ Êú™Ê£ÄÊµãÂà∞ÊòéÊòæÈîôËØØ' : ''}`,
          },
        ],
      };
      
    } finally {
      await page.close();
    }
  }

  async cleanup() {
    if (this.browser) {
      await this.browser.close();
    }
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('AI Chat Plugin Browser MCP Server running on stdio');
  }
}

const server = new BrowserServer();
server.run().catch(console.error);
